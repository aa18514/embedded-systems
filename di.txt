distributed algorithms goes back to the late 1970's most of the work was done in 1980's and 1990's - distributed databases - distributed filesystems - paid little attention to distributed algorithms - gained a remergence in mid 2000's - cloud computing - clusters of hundreds of thousands of computer in a big warehouse in the north pole for example.

introduction to reliable and secure distributed programming - oriented towards software engineers - takes a software engineering approach 
communication and agreement abstraction for fault tolerant asynchronous distributed systems - predicate logic 
elements of distributed computing vijay garg, wiley, 2002, more formal descriptions and proofs
distributed algorithms, nancy lynch, morgan kaufmann, 1996. The 'bible'

programming erlang: softare for a concurrent world, Joe Armstrong 
learn you some erlang for great good! Fred Hebert
A concise guide to erlang, david matuszek, 2010


why a distributed system? 
computation and data distribution 
performance 
reliability and availability 
scalability, modularity, evolvability
hetrogenity of hardware (CPU, networks, stroage) and software (OS's, implementations, versions).

what are the disadvantages of distributed systems? harder to design. 


our view of distributed systems: 
set of processes connected by a network 
executed on machines (that can be located across the globe)
communicate via message passing, not shared memory 
the processes that are far apart need to communicate with each other need to pass data to each other. 


A distributed system is one in which the failure of a computer you didnt even know existed can render your own computer unusable, Leslie Lamport
distributed systems are concerned with uncertainit  - working in the presence of delays, failures etc, also attacks by advesaries, mobility of devices, energy consumption

what's the problem? its required safety and liveness properties

assumptions
	timing, failure, communication, etc

3. algorithm
	what's the solution? 
	how do we know it works? we need to provide a proof, 
	whats the cost?

mutual exclusion 

safety 
	two processes should not have permission to use a critical section simultaneously. 

liveness 
	every request for the critical section is eventually granted

fairness
	different requests must be granted in the order they are made

synchronous 
	upper bound on process delays .e time taken to do a step(receive, message, compute, send message). 
	upper bound on time for a message to be deliver 
	greate for reasoning about systems

asynchronous systmes: 
	process and communication take arbitary time
	no assumption that processes have physical clocks, but can sometimes be useful to use logical clocks.

different classes of failure,  processes stop failure

byzantine failure - arbitary failure process can be misbehaving for mysterious reasons causing probems for the rest of the systems - requirement for having certain number of correct processes

example consensus 

agreement: two non faulty processes cannot decide on different values, i.e all correct processes decide on the same value 

validity 
if all processes are propose the same value, then the decided values should be the proposed value (if we propose something we should reach an agreement on that)

termination 
	system reaching agreement in finity time 

pacsocs
chubby lock 


assumptions - communication 

asynchronous message passing 
process sending a message continues after sending a message 

when required we will build synchronous message passing mechanism e.g process sending a message waits until message is delivered to recieving process. 
TCP -> reliable message communication 
failure - drop messages

complexity measures 

the complexity of a distribtued algorithm can be measured in different ways 
number of messages exchanged
number of bits exchanged - when messages are big
time taken - asynchronous systems need an external observer


variables 

can be bound to a value 
value cannot be changed 
comprise letters, digits, _, @
start with an uppercase letter, __

atoms 
denote literals 
comprise letters, digits, _,@
start with a lowecase letters

no booleans - true or false literals 
tuple within a tuple within it


pattern matching expression 
{var1, .., varnN} =  {expr1, ,exprN}
matches expres1 with var1, etc
fails if any match fails 
A = {red, 12}
{B, C0 = A }
